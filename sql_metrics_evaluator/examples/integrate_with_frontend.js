/**
 * Example JavaScript code to integrate SQL metrics evaluator with the LLM comparison app frontend
 * 
 * This file demonstrates how to call the SQL metrics evaluator API from the frontend
 * and display the results in the UI.
 */

// Configuration
const API_URL = 'http://localhost:8000';

/**
 * Evaluate a SQL query using the metrics evaluator API
 * @param {string} generatedQuery - The SQL query generated by the model
 * @param {string} referenceQuery - The reference SQL query to compare against
 * @param {string} complexity - The complexity level of the query (simple, medium, complex)
 * @returns {Promise<Object>} - The evaluation results
 */
async function evaluateQuery(generatedQuery, referenceQuery, complexity = 'medium') {
  try {
    const response = await fetch(`${API_URL}/evaluate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        generated_query: generatedQuery,
        reference_query: referenceQuery,
        query_complexity: complexity,
      }),
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error evaluating query:', error);
    throw error;
  }
}

/**
 * Evaluate multiple queries in batch
 * @param {Array<Object>} queries - Array of query objects with generated_query, reference_query, and complexity
 * @returns {Promise<Object>} - The batch evaluation results
 */
async function evaluateBatch(queries) {
  try {
    const response = await fetch(`${API_URL}/evaluate/batch`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        requests: queries,
      }),
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error evaluating batch:', error);
    throw error;
  }
}

/**
 * Update the UI with evaluation metrics
 * @param {string} modelId - The ID of the model
 * @param {Object} metrics - The evaluation metrics
 */
function updateMetricsUI(modelId, metrics) {
  // Get the metrics container for this model
  const metricsContainer = document.querySelector(`#${modelId}-metrics`);
  if (!metricsContainer) {
    console.error(`Metrics container not found for model ${modelId}`);
    return;
  }

  // Create metrics HTML
  const metricsHTML = `
    <div class="metrics-card">
      <h4>SQL-Specific Metrics</h4>
      <div class="metric">
        <span class="metric-name">Execution Accuracy:</span>
        <span class="metric-value">${(metrics.execution_accuracy * 100).toFixed(2)}%</span>
      </div>
      <div class="metric">
        <span class="metric-name">Exact Match Accuracy:</span>
        <span class="metric-value">${(metrics.exact_match_accuracy * 100).toFixed(2)}%</span>
      </div>
      <div class="metric">
        <span class="metric-name">Logical Form Accuracy:</span>
        <span class="metric-value">${(metrics.logical_form_accuracy * 100).toFixed(2)}%</span>
      </div>
      
      <h4>General Performance Metrics</h4>
      <div class="metric">
        <span class="metric-name">Inference Latency:</span>
        <span class="metric-value">${metrics.inference_latency.toFixed(2)} ms</span>
      </div>
      <div class="metric">
        <span class="metric-name">Complexity Handling:</span>
        <span class="metric-value">${(metrics.complexity_handling * 100).toFixed(2)}%</span>
      </div>
      ${metrics.zero_shot_performance ? `
      <div class="metric">
        <span class="metric-name">Zero-shot Performance:</span>
        <span class="metric-value">${(metrics.zero_shot_performance * 100).toFixed(2)}%</span>
      </div>
      ` : ''}
    </div>
  `;

  // Update the metrics container
  metricsContainer.innerHTML = metricsHTML;
}

/**
 * Handle form submission and evaluate the query
 * @param {Event} event - The form submission event
 */
async function handleFormSubmit(event) {
  event.preventDefault();
  
  // Get form values
  const queryText = document.getElementById('query-input').value;
  const expectedSql = document.getElementById('expected-sql').value;
  const complexity = document.getElementById('complexity-select').value;
  
  // Show loading state
  document.getElementById('results-container').classList.add('loading');
  
  try {
    // Get model responses (this would be from your existing API)
    const modelResponses = await getModelResponses(queryText);
    
    // For each model response, evaluate it
    for (const [modelId, response] of Object.entries(modelResponses)) {
      // Evaluate the query
      const evaluationResult = await evaluateQuery(
        response.response,
        expectedSql,
        complexity
      );
      
      // Update the UI with the metrics
      updateMetricsUI(modelId, evaluationResult.metrics);
    }
  } catch (error) {
    console.error('Error:', error);
    // Show error message
    document.getElementById('error-message').textContent = `Error: ${error.message}`;
    document.getElementById('error-message').style.display = 'block';
  } finally {
    // Hide loading state
    document.getElementById('results-container').classList.remove('loading');
  }
}

/**
 * Initialize the metrics evaluator integration
 */
function initMetricsEvaluator() {
  // Add event listener to the form
  const form = document.getElementById('query-form');
  if (form) {
    form.addEventListener('submit', handleFormSubmit);
  }
  
  // Add metrics containers to each model result card
  const modelCards = document.querySelectorAll('.model-card');
  modelCards.forEach(card => {
    const modelId = card.id.replace('-card', '');
    const metricsContainer = document.createElement('div');
    metricsContainer.id = `${modelId}-metrics`;
    metricsContainer.className = 'metrics-container';
    card.appendChild(metricsContainer);
  });
  
  console.log('SQL Metrics Evaluator integration initialized');
}

// Initialize when the DOM is loaded
document.addEventListener('DOMContentLoaded', initMetricsEvaluator);

// CSS styles for metrics display
const styles = `
.metrics-container {
  margin-top: 20px;
  padding: 15px;
  background-color: #f8f9fa;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.metrics-card h4 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 16px;
  color: #333;
}

.metric {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  font-size: 14px;
}

.metric-name {
  font-weight: 500;
  color: #555;
}

.metric-value {
  font-weight: 600;
  color: #007bff;
}

#results-container.loading {
  opacity: 0.7;
  pointer-events: none;
}

#error-message {
  display: none;
  padding: 10px;
  background-color: #f8d7da;
  color: #721c24;
  border-radius: 4px;
  margin-bottom: 20px;
}
`;

// Add styles to the document
const styleElement = document.createElement('style');
styleElement.textContent = styles;
document.head.appendChild(styleElement);

// Mock function to get model responses (replace with your actual implementation)
async function getModelResponses(queryText) {
  // This would be replaced with your actual API call
  console.log(`Getting model responses for query: ${queryText}`);
  
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Return mock responses
  return {
    'gpt-base': {
      response: 'SELECT * FROM users WHERE age > 18;',
      executionTime: 250
    },
    'gpt-finetuned': {
      response: 'SELECT * FROM users WHERE age > 18;',
      executionTime: 180
    },
    'gpt4o-mini-base': {
      response: 'SELECT * FROM users WHERE age > 18;',
      executionTime: 150
    },
    'gpt4o-mini-finetuned': {
      response: 'SELECT * FROM users WHERE age > 18;',
      executionTime: 120
    }
  };
} 